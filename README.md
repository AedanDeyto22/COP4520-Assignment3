# COP4520-Assignment3

## To Run Code in the Command Line for Problem 1:
* Make sure you are in the Assignment3-Problem1 directeory
* First type "javac BirthdayPresentsParty.java"
* Then type "java BirthdayPresentsParty"

## To Run Code in the Command Line for Problem 2:
* Make sure you are in the Assignment3-Problem2 directeory
* First type "javac TemperatureModule.java"
* Then type "java TemperatureModule"

## Summary and Testing of Problem 1
The way I chose to handle this problem was first figuring out how to add the amount of presents into a sorted linked list and remove the same amount of gift into the list to write the thank you cards. So the way I choose to deal with this issue is by making sure the first presents added into the list would be the first presents to be removed, so that I would know what gifts I already add into the list so that I can remove it. The way this was implemented was using an array list that was filled from 0 to 500,000 and then making sure to shuffle the list so that I can present the unsorted bag of presents. Then using atomic integers the servants would get the index of the gfit they would add to the list and increment the count. And, when the servants would want to remove a gift to write the card, they would follow the same array list but keep track of the atomic integer index for add to make sure it doesn’t overtake it. Also when it comes to adding and removing into the list, the process I chose was using a non-blocking list since it allows all the threads to edit the list without the need of a lock and it's also a quick process. Since nodes have a marked value that we can use to tell if the node is suppose to be deleted or not, we are able to safely add and remove nodes at the same time. Becuase we are using a class to help keep track of the current node and the predecessor node, which helps use edit the list safely since when finding these two node we clean up any marked nodes that we encounter. And we use compare and set to make sure we update the list correctly.

When it comes to efficiency and correctness, my implantation fills in those requirements. Since at the very end the servants are able to add 500,000 gifts into the linked list as well as removing the gifts from the list and creating the thank you cards. Also I made sure the servants would more often add or remove a gift but still be able to search for a gift based on the minotaurs request. Also, the use of the unsorted list helps us organize how we add and remove gifts, so that we can gurantee that all gifts are add in and remove efficiently. During my testing I made sure the linked list was empty after all the threads ran, so I made the link list print all the keys of its nodes until it reached null which only produced a -1 which was the key of the head of the list. Showing that after all the threads run we are able to empty up the list. When it comes to the efficiency of my implantation after running it a couple of times, the execution is around 2000 milliseconds or just 2 seconds. 

## Summary and Testing for Problem 2
When it comes to problem 2, I used the same link list process I used in problem 1 by using a non-locking concurrent link list but with some modifications such as allowing add to add in duplicate keys. So the main challenge to this problem was trying to figure out how to get the largest temp difference within a 10 minute interval. My solution to this is by using multiple linked lists. I used up to 61 linked lists in my implementation since the first linked list will hold all of the reading of all 8 sensors for the hour and the other ones will hold the reading  of the 8 sensors within a specific minute. The reason for this is so that we can figure out what is the lowest and highest temp within a single minute, which we will store in a local array list respectively for min and max. In these array lists we will make sure it doesn’t exceed the size of 10 to represent the 10 minute interval, and if it does we remove the first value in the array list. So the way I made this. The way we know which list we are trying to look at is by sending the functions an index to represent which list we are looking into.  So my implementation uses a total of 9 threads, threads 1-8 represents the sensor threads and the 9th thread is the thread that gets the highest temp difference within a 10 minute interval and the top 5 lowest and highest temperature.  The sensor threads would just go a for loop from 0 to 60 to represent the minutes within an hour and add those reading into the main list located in index 0 and the minute list which would be i + 1, i being the current for loop value. The reading thread would look into those minute link lists and wait until they are size 8 to know if that minute has passed, and so it will grab the max and min reading of that minute and produce its diff value based on the max and min value of the max and min array list. After it goes through all 60 minutes, it finds the largest difference from the diff arraylist and produces the top 5 highest and lowest temp within the hour.

So this implementation is both correct and efficient, since it's able to print all the necessary print statements without having to slow down the sensor from producing their minute reading. The reason for this is because we are doing the reading and calculations all at the exact same time because of there being 9 threads over all. While the 8 sensor threads are producing their reading, the 9th thread is using those readings to produce a local array which will tell us the largest difference in temp within a 10 minute interval. Also, the use of multiple link lists allows us to see the overall reading within the hour, but also specially in each minute which helps the 9th thread. We also used a count down latch so that we know when all 9 threads are done. When it comes to testing, I’ve tested this thread to show 4 hours, 10 hours, and 20 hours. So for 4 hours the execution time was about 200 milliseconds. When it comes to 10 hours the execution time was about 400 milliseconds. And when it comes to 20 hours the execution time was about 800 milliseconds to complete. 
